## 📚 정렬(Sorting)이란?

데이터를 **특정한 기준에 따라 순서대로 나열하는 것**을 말한다.

### 1. 선택 정렬(Selection Sort)

- **IDEA:** 매 단계마다 **가장 작은 데이터**를 선택한다.
- 데이터가 여러 개 있을 때 가장 작은 데이터를 선택해 **맨 앞의 데이터와 교환**한다.
- 이후 다음으로 작은 데이터를 선택해 **앞에서 두 번째 데이터와 교환하는 과정을 반복**한다.
- 시간 복잡도는 O(N^2)이다.
- 특정 리스트에서 **최솟값을 반복적으로 찾는 경우**에 사용할 수 있다.

### 2. 삽입 정렬(Insertion Sort)

- **IDEA:** 데이터를 하나씩 확인하며 **각 데이터를 적절한 위치에 삽입**한다.
- 현재 데이터가 삽입되기 이전의 데이터는 **이미 정렬되어 있다고 가정**한다.
- 삽입 정렬은 **두 번째 데이터부터 정렬을 시작**한다.
- 필요할 때만 위치를 변경하므로 **불필요한 연산이 줄어든다**.
- 데이터가 **거의 정렬되어 있을 때 효율적으로 동작**한다.
- 시간 복잡도는 O(N^2)이다.
- 최선의 경우 시간 복잡도는 O(N)이다.
- 거의 정렬된 상태로 입력이 주어지는 경우 **다른 정렬 알고리즘보다 효과적**이다.

### 3. 퀵 정렬(Quick Sort)

- **IDEA:** 기준 데이터를 설정하고 **기준보다 큰 데이터와 작은 데이터의 위치를 교환**한다.
- 기준이 되는 값을 **피벗(Pivot)이라고 한다.**
- **호어 분할(Hoare Partition) 방식**에서는 리스트의 **첫 번째 데이터를 피벗으로 설정**한다.
- 왼쪽에서부터 **피벗보다 큰 데이터**를 찾는다.
- 오른쪽에서부터 **피벗보다 작은 데이터**를 찾는다.
- 두 데이터의 위치를 교환하여 **파티션을 수행**한다.
- **파티션**은 피벗을 기준으로 **데이터를 두 부분으로 나누는 과정**이다.
- **재귀적으로 정렬을 수행**하며 종료 조건은 **리스트의 원소 개수가 1개인 경우**이다.
- 평균 시간 복잡도는 O(NlogN)이다.
- 데이터가 이미 정렬되어 있는 경우 시간 복잡도는 O(N^2)이다.

### 4. 계수 정렬(Counting Sort)

- 계수 정렬은 **특정 조건에서만 사용할 수 있지만 매우 빠른 정렬 알고리즘**이다.
- 시간 복잡도는 O(N + K)이다.
- 여기서 **N은 데이터의 개수**, **K는 데이터 중 최댓값**이다.
- 데이터의 값이 **정수이며 범위가 제한되어 있을 때만 사용 가능**하다.
- 데이터의 값 범위를 모두 포함할 수 있는 **크기의 리스트를 별도로 선언**해야 한다.
- 각 데이터를 확인하며 **해당 값과 동일한 인덱스의 값을 1씩 증가**시킨다.
- 기록된 정보를 바탕으로 **정렬된 결과를 생성**한다.
- **동일한 값이 여러 번 등장하는 경우**에 적합하다.

### 정렬 문제 유형

- (1) 정렬 라이브러리를 사용해 해결할 수 있는 문제는 **기본 정렬 함수의 사용법을 숙지**하면 된다.
- (2) 정렬 알고리즘의 원리를 묻는 문제는 **선택 정렬, 삽입 정렬, 퀵 정렬의 동작 과정 이해**가 필요하다.
- (3) 더 빠른 정렬이 필요한 문제는 **계수 정렬과 같은 특수 정렬 알고리즘**이나 **알고리즘 구조 개선**이 필요하다.
