### 1. 플로이드–워셜(Floyd–Warshall) 최단 경로 알고리즘

- **시간 복잡도:** O(N³)
- **다이나믹 프로그래밍(Dynamic Programming)** 기반의 알고리즘이다.
- **모든 노드에서 다른 모든 노드까지의 최단 거리**를 한 번에 계산한다.
- 모든 거리 정보를 저장해야 하므로 **2차원 리스트(행렬)** 를 사용한다.
- 알고리즘은 **‘거쳐 가는 노드’** 를 기준으로 단계적으로 수행된다.

---

#### 📌 핵심 아이디어

- 각 단계마다 특정 노드 `k`를 **중간에 거쳐 가는 경우**를 고려한다.
- 노드 `a`에서 `b`로 가는 최단 거리는 다음 식으로 갱신된다.
- D<sub>ab</sub> = min(D<sub>ab</sub>, D<sub>ak</sub> + D<sub>kb</sub>)

- 즉, **직접 가는 경로보다 `k`를 거쳐 가는 경로가 더 짧다면 갱신**한다.

---

#### 📌 알고리즘 수행 과정

- **[Step 0] 초기화**
  - **연결된 간선**은 해당 비용으로 초기화한다.
  - **연결되지 않은 간선**은 무한(INF)으로 설정한다.
  - 자기 자신으로 가는 비용은 0으로 초기화한다.

- **[Step 1 ~ N] 갱신**
  - `1`번 노드부터 `N`번 노드까지를 **차례대로 거쳐 가는 노드(k)** 로 설정한다.
  - 모든 `(a, b)` 쌍에 대해:
    - 기존 거리: D<sub>ab</sub>
    - 거쳐 가는 경우: D<sub>ak</sub> + D<sub>kb</sub>
    - 두 값 중 **더 작은 값**을 테이블에 저장한다.

---

#### ✅ 특징 요약

- 구현이 직관적이고 코드가 간단하다.
- 노드 수가 **적을 때(N ≤ 500 정도)** 적합하다.
- 노드 수가 커지면 **O(N³)** 복잡도로 인해 성능 부담이 크다.
